{"version":3,"sources":["../src/lib/utils.ts","../src/lib/client.ts","../api.ts"],"names":["devalue","tryParse","data","jsonToFormData","key","i","formData","stringifiedValue","value","fileKey","formDataToJson","createRecursiveProxy","callback","path","_obj","_1","_2","args","createClient","endpoint","headers","f","onError","method","maybeVerb","res","reader","decoder","buffer","first","chunk","done","lines","line","result","api"],"mappings":"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","sourcesContent":["import * as devalue from 'devalue';\nexport const tryParse = <C>(data: unknown) => {\n\ttry {\n\t\treturn (typeof data !== 'string' ? data : JSON.parse(data)) as C;\n\t} catch (e) {\n\t\treturn data as C;\n\t}\n};\n\nexport const jsonToFormData = (data: unknown, key = 'input') => {\n\tlet i = 0;\n\tconst formData = new FormData();\n\tconst stringifiedValue = devalue.stringify(\n\t\t{ [key]: data },\n\t\t{\n\t\t\tFile: (value) => {\n\t\t\t\tif (value instanceof File) {\n\t\t\t\t\tconst fileKey = `#FILE_${i}_FILE#`;\n\t\t\t\t\tformData.set(fileKey, value);\n\t\t\t\t\ti++;\n\t\t\t\t\treturn fileKey;\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t);\n\tformData.set(key, stringifiedValue);\n\treturn formData;\n};\nexport const formDataToJson = (formData: FormData, key = 'input') => {\n\treturn devalue.parse(formData.get(key) as string, {\n\t\tFile: (value) => {\n\t\t\treturn formData.get(value) as File;\n\t\t},\n\t})[key];\n};\n\nexport const inputToSearchParams = (input: unknown) => {\n\treturn `input=${encodeURIComponent(\n\t\tdevalue.stringify(input, {\n\t\t\tFile: (value) => {\n\t\t\t\tif (value instanceof File) {\n\t\t\t\t\treturn 'file';\n\t\t\t\t}\n\t\t\t},\n\t\t}),\n\t)}`;\n};\n\nexport const searchParamsToInput = (searchParams: URLSearchParams) => {\n\treturn devalue.parse(decodeURIComponent(searchParams.get('input') || '{}'), {\n\t\tFile: (value) => {\n\t\t\treturn 'file';\n\t\t},\n\t});\n};\n","import type { API, MaybePromise, Router, StreamCallback } from './types';\nimport { tryParse, jsonToFormData, formDataToJson } from './utils';\n\nexport const createRecursiveProxy = (callback: (opts: { path: string[]; args: unknown[] }) => unknown, path: string[]) => {\n\tconst proxy: unknown = new Proxy(() => {}, {\n\t\tget(_obj, key) {\n\t\t\tif (typeof key !== 'string') return undefined;\n\t\t\treturn createRecursiveProxy(callback, [...path, key]);\n\t\t},\n\t\tapply(_1, _2, args) {\n\t\t\treturn callback({\n\t\t\t\tpath,\n\t\t\t\targs,\n\t\t\t});\n\t\t},\n\t});\n\treturn proxy;\n};\n\nexport const createClient = <R extends Router>(\n\t{\n\t\tendpoint = '/api',\n\t\theaders,\n\t\tfetch: f = fetch,\n\t\tonError = () => {},\n\t}: {\n\t\tendpoint?: string;\n\t\theaders?: HeadersInit | (<I = unknown>({ path, input }: { path: string; input: I }) => MaybePromise<HeadersInit>);\n\t\tfetch?: typeof fetch;\n\t\tonError?: (error: unknown) => void;\n\t} = {\n\t\tendpoint: '/api',\n\t\tonError: () => {},\n\t},\n) => {\n\treturn createRecursiveProxy(async ({ path, args }) => {\n\t\tlet method = 'POST';\n\t\tconst maybeVerb = path[path.length - 1];\n\t\tconst verbs = new Set(['get', 'put', 'delete', 'update', 'patch']);\n\t\tif (verbs.has(maybeVerb)) {\n\t\t\tpath.pop();\n\t\t\tmethod = maybeVerb.toUpperCase();\n\t\t}\n\t\treturn f(`${endpoint}/${path.join('/')}${method === 'GET' ? '' : ''}`, {\n\t\t\tmethod: 'POST',\n\t\t\tbody: method === 'GET' ? undefined : jsonToFormData(args[0]),\n\t\t\theaders: Object.assign(\n\t\t\t\t{\n\t\t\t\t\t'x-wrpc-client': 'true',\n\t\t\t\t},\n\t\t\t\ttypeof headers === 'function'\n\t\t\t\t\t? await headers({\n\t\t\t\t\t\t\tpath: path.join('/'),\n\t\t\t\t\t\t\tinput: args[0],\n\t\t\t\t\t\t})\n\t\t\t\t\t: headers,\n\t\t\t),\n\t\t}).then(async (res) => {\n\t\t\tconsole.log(res.headers.get('content-type'), res.headers.get('content-type') === 'multipart/form-data; boundary=\"abcd\"');\n\t\t\tif (res.headers.get('content-type') === 'text/event-stream') {\n\t\t\t\tconst reader = res.body!.getReader();\n\t\t\t\tconst decoder = new TextDecoder();\n\t\t\t\tlet buffer = '';\n\t\t\t\tlet first = true;\n\t\t\t\tconst callback = (chunk: string, done: boolean) => {\n\t\t\t\t\tif (done) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst lines = (buffer + chunk).split('\\n');\n\t\t\t\t\tbuffer = lines.pop()!;\n\t\t\t\t\tlines.forEach((line, i) => {\n\t\t\t\t\t\tif (first && i === 0 && line === '') {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(args[1] as any)({\n\t\t\t\t\t\t\tchunk: tryParse(line),\n\t\t\t\t\t\t\tfirst,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\twhile (true) {\n\t\t\t\t\tconst { done, value } = await reader.read();\n\t\t\t\t\tif (done) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcallback(decoder.decode(value), done);\n\t\t\t\t}\n\t\t\t} else if (res.headers.get('content-type')?.includes('multipart/form-data')) {\n\t\t\t\tconst formData = await res.formData();\n\t\t\t\tconst result = formDataToJson(formData as FormData, 'result') as { result: unknown };\n\t\t\t\tif (res.ok) {\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\tonError(result);\n\t\t\t\t}\n\t\t\t} else if (res.headers.get('content-disposition')?.includes('filename')) {\n\t\t\t\treturn new File([await res.arrayBuffer()], res.headers.get('content-disposition')?.split('filename=')[1] || 'file');\n\t\t\t} else {\n\t\t\t\tconsole.log(res.headers.get('content-type'));\n\t\t\t}\n\t\t});\n\t}, []) as API<R>;\n};\n","import { createClient } from './src/lib/client';\nimport { AppRouter } from './src';\n\nexport const api = createClient<AppRouter>({\n\tendpoint: 'https://example.com/api/',\n});\n"]}